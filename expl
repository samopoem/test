이전 Reference Code 편과 연결되는 글이기는 하지만 거기에 추가하면 이미 그 글을 보신 분은 안보실 것 같아서 새로운 글을 만들었고 

또한, 그 동안 제가 쓴 글을 열심히 보셨는데 아직 adv를 취득하지 못하는 분들께 드리는 글입니다.

(이제 정말 더 자세히 설명 드릴 것이 없습니다.)





지난주에 Reference Code가 공개되고 최근 Adv에 많이 나오고 Pro에도 많은 도움이 되는 조합/순열 부분을 살펴보았는데 

특정 문제에 대한 풀이라서 없는 것보다는 낫겠지만 저는 바로 다른 문제에 적용할 수 있을 것 같지 않았습니다. 




그리고, 그 동안 코드를 요청하시는 분들이 많았는데 사람마다 맞는 코드도 달라서 제가 가지고 있는 코드를 올리지 않았는데

이번 부서 세미나 시간에 함께 이 코드를 보기도 해서 첨부하고 약간의 설명을 드립니다.

(첨부 코드는 http://hochulshin.com/permutation-composition-summary/ 에서 가져오고 약간 수정하였습니다.)





중복여부는 #define REPEAT 부분을 제거 하거나 살려면 사용하실 수 있고 1~2줄만 다르기 때문에 외우시는데 문제가 없을 것 같습니다.

코드를 보면 실제 외워야 하는 부분은 많지 않습니다.




제가 말씀드리는 문제 적용 방법은 다음과 같습니다.

1) 문제가 순열/조합/중복순열/중복조합 중에 어떤 문제인지 식별한다.

   "최근 S/W 써티 adv 등급에서만 통하는 미립자 Tip (마지막 편, 이번주 보시는 분들 꼭 보고 가세요.) " 글에서 나온 문제의 1번 문제를 예를 들면

   (실제 문제에 나오는 사탕무게나 나사의 규격등은 무시하고 일단)


   이 문제는 조합문제이니 첨부화일의 조합문제를 코딩하여 출력해 본다.

   





    3 2 1
    3 2 0

    3 1 0
    2 1 0





2) 사탕의 갯수가 정해지지 않았으나 최소 1개 최대 2개라고 하면

    main에 for 문을 추가한다.




    int main(void)    
    {
        int i;
        for(i=1;i<=2;i++)
        {
            Comb(10, i, i);        
        }
        return 0;
   }





3) process에 계산식을 추가, 다른 부분을 건드릴 것이 없습니다.




    int candy[10] = {10, 20, 30, 40, 50, 60, 70, 80, 90, 100};




    void process(int q)
    {
        int i;
        int sum = 0;
        for(i = q-1; i>= 0; i--)
        {
            printf("%d ", T[i]);
        }




        for(i = q-1; i>= 0; i--)    
        {
            printf("%d ", candy[T[i]]);
            sum += candy[T[i]];
        }





        if (sum >=95 && sum <=105)
        {
            printf(" O");
        }
        printf("\n");
    }




4) 출력해 보면 아래와 같습니다.




9 100  O
8 90
7 80
6 70
5 60
4 50
3 40
2 30
1 20
0 10
9 8 100 90
9 7 100 80
9 6 100 70
9 5 100 60
9 4 100 50
9 3 100 40
9 2 100 30
9 1 100 20
9 0 100 10
8 7 90 80
8 6 90 70
8 5 90 60
8 4 90 50
8 3 90 40
8 2 90 30
8 1 90 20
8 0 90 10  O
7 6 80 70
7 5 80 60
7 4 80 50
7 3 80 40
7 2 80 30
7 1 80 20  O
7 0 80 10
6 5 70 60
6 4 70 50
6 3 70 40
6 2 70 30  O
6 1 70 20
6 0 70 10
5 4 60 50
5 3 60 40  O
5 2 60 30
5 1 60 20
5 0 60 10
4 3 50 40
4 2 50 30
4 1 50 20
4 0 50 10
3 2 40 30
3 1 40 20
3 0 40 10
2 1 30 20
2 0 30 10
1 0 20 10








10개의 사탕이 있으면 최대 2개를 고르면 위와 같이 5개의 경우가 있는 것이 조건을 만족시킵니다.




그동안 나온 다른 순열 조합 문제도 첨부화일에서 main과 process 부분만 수정하면 풀 수 있을 것으로 생각합니다.




회사 adv 문제가 순열/조합으로 나온다면 어떤 완전탐색인지 알고 위의 것과 같은 코드 추가만 하면 pass 할 수 있을 것 같습니다.

꼭 참고하여 이번주에 pass 하기시 바랍니다.
